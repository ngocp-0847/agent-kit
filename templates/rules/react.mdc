---
description: React component patterns and best practices
globs: ["**/*.tsx", "**/*.jsx"]
alwaysApply: false
---

# React Guidelines

## Component Design
- Prefer functional components with hooks
- Keep components small and focused
- Use composition over inheritance
- Design components as compound components when appropriate

## Props & State
- Destructure props in function signature
- Use TypeScript interfaces for prop types
- Keep state as close to where it's used as possible
- Lift state only when necessary for sharing

## Hooks
- Follow the Rules of Hooks
- Extract reusable logic into custom hooks
- Use `useMemo` and `useCallback` judiciously (profile first)
- Prefer `useReducer` for complex state logic

## Event Handlers
- Prefix with "handle" (e.g., `handleClick`, `handleChange`)
- Define handlers outside of JSX for readability
- Use proper TypeScript event types

## Performance
- Avoid inline object/array creation in JSX
- Use React.memo only when proven necessary
- Implement proper key props in lists
- Consider code-splitting for large components

## Patterns to Follow
```tsx
// Good: Compound component pattern
<Select>
  <Select.Option value="a">Option A</Select.Option>
  <Select.Option value="b">Option B</Select.Option>
</Select>

// Good: Custom hook for logic
function useToggle(initial = false) {
  const [state, setState] = useState(initial);
  const toggle = useCallback(() => setState(s => !s), []);
  return [state, toggle] as const;
}
```

## Avoid
- Prop drilling more than 2 levels (use Context or state management)
- Business logic in components (extract to hooks/utils)
- Inline styles (use CSS-in-JS or CSS modules)
- Index as key in dynamic lists
